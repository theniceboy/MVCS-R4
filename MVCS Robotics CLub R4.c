#pragma config(Sensor, in1,    ejctPot,        sensorPotentiometer)
#pragma config(Motor,  port1,           mEject,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           mL1,           tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           mL2,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           mR1,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           mR2,           tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Eject Pot Rest: 2200
Eject Pot Ejected: 1400
Eject Motor Eject: (-)


*/
int ejectRest = 2200;
int ejectOut = 1000;

task trayCtrl {
	while(true){
		if(vexRT[Btn7U ]){
			startMotor(mEject, -100);
			while(SensorValue(ejctPot) >= ejectOut){
				wait1Msec(1);
			}
			startMotor(mEject, 100);
			while(SensorValue(ejctPot) <= ejectRest){
				wait1Msec(1);
			}
			stopMotor(mEject);
		}
	}
}
task clawCtrl {

}
task main()
{
	startTask(trayCtrl);
	float theta = 90, power = 0, x = 0, y = 0;
	while (true) {
		x = vexRT[Ch3];
		y = vexRT[Ch4];
		power = sqrt(x * x + y * y);
		if (x == 0) {
			theta = (y > 0 ? 90 : 270);
		} else {
			theta = radiansToDegrees(atan(y/x));
		}
		if (theta >= 340 || theta >= 0 && theta <= 20) {
			motor[mL1] = motor[mL2] = power;
			motor[mR1] = motor[mR2] = -power;
		} else if (theta > 20 && theta <= 90) {
			motor[mL1] = motor[mL2] = power;
			motor[mR1] = motor[mR2] = power * sinDegrees(theta);
		} else if (theta > 90 && theta < 160) {
			motor[mL1] = motor[mL2] = abs(sinDegrees(theta) * power);
			motor[mR1] = motor[mR2] = power;
		} else if (theta >= 160 && theta <= 200) {
			motor[mL1] = motor[mL2] = -power;
			motor[mR1] = motor[mR2] = power;
		} else if (theta > 200 && theta <= 270) {
			motor[mL1] = motor[mL2] = -power * sinDegrees(theta - 180);
			motor[mR1] = motor[mR2] = -power;
		} else if (theta > 270 & theta < 340) {
			motor[mL1] = motor[mL2] = -power;
			motor[mR1] = motor[mR2] = -power * sinDegrees(theta - 270);
		}

 		EndTimeSlice();
	}

}
